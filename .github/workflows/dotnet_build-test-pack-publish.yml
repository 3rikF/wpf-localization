name: .NET Core Desktop

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch

jobs:

  #----------------------------------------------------------------------------------------------------------------------------------------
  build:

    strategy:
      matrix:
        CONFIGURATION: [Debug, Release]

    # For a list of available runner types, refer to
    # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on
    runs-on: windows-latest

    permissions:
      contents: read  # Required to checkout code

    env:
      # Replace with your solution name, i.e. MyWpfApp.sln.
      SOLUTION_NAME: "./WpfLocalization.slnx"

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Install the .NET Core workload
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x

    # Add  MSBuild to the PATH: https://github.com/microsoft/setup-msbuild
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2

    # Restore the application
    - name: Restore the application
      run: dotnet restore $env:SOLUTION_NAME

    # Build the solution
    - name: Build solution
      run: dotnet build $env:SOLUTION_NAME --configuration $env:Configuration --no-restore
      env:
        Configuration: ${{ matrix.CONFIGURATION }}

    # Execute all unit tests in the solution without rebuilding
    - name: Execute unit tests
      run: dotnet test $env:SOLUTION_NAME --configuration $env:Configuration --no-build --collect:"XPlat Code Coverage;Format=json,cobertura"
      env:
        Configuration: ${{ matrix.CONFIGURATION }}

    # taken from a Codecov example
    - name: Upload coverage reports to Codecov
      #uses: codecov/codecov-action@v4
      uses: codecov/codecov-action@v5
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./TestResults/**/*.cobertura.xml
        flags: unittests
    #   name: codecov-umbrella


  #----------------------------------------------------------------------------------------------------------------------------------------
  publish:
    needs: build
    # Only run on main branch when tests are successful
    if: github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    permissions:
      contents: write  # Required to create and push tags
      packages: write  # Required for publishing packages

    env:
      SOLUTION_NAME: "./WpfLocalizationTest.slnx"
      PROJECT_PATH: "./Source/ErikForwerk.Localization.WPF/ErikForwerk.Localization.WPF.csproj"

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Install the .NET Core workload
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x

    # Determine the latest version tag and calculate new version
    - name: Determine new version
      id: version
      shell: bash # Explizit Bash verwenden
      run: |
        # Die Bash-Logik zur Versionsbestimmung
        # ------------------------------------

        # 1. Tags holen
        git fetch --tags

        # 2. Letzten SemVer-Tag finden (sortiert und nimmt den höchsten)
        # Sortiert tags numerisch und wählt den letzten (höchsten)
        latestTag=$(git tag -l "v*.*.*" | sort -V | tail -n 1)

        if [ -z "$latestTag" ]; then
          # Kein Tag gefunden, starte bei v0.0.0
          latestTag="v0.0.0"
        fi

        # 3. Versionsteile extrahieren
        # Entferne das 'v' und zerlege die Version
        version=${latestTag#v}
        IFS='.' read -r major minor patch <<< "$version"

        # 4. Bump-Typ bestimmen (Fallback auf 'patch')
        bump_type="${{ github.event.inputs.bump }}"
        if [ -z "$bump_type" ]; then
          bump_type="patch"
        fi

        # 5. Version erhöhen (Bash case-Anweisung)
        case "$bump_type" in
          major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
          minor)
            minor=$((minor + 1))
            patch=0
            ;;
          patch)
            patch=$((patch + 1))
            ;;
        esac

        newVersion="$major.$minor.$patch"
        newTag="v$newVersion"

        # 6. Ausgabe im Log
        echo "Previous version: $latestTag"
        echo "New version: $newTag"

        # 7. Outputs für nachfolgende Schritte setzen (Bash-Syntax)
        echo "version=$newVersion" >> $GITHUB_OUTPUT
        echo "tag=$newTag" >> $GITHUB_OUTPUT

    # Create and push new version tag
    - name: Create version tag
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ steps.version.outputs.tag }}
        git push origin ${{ steps.version.outputs.tag }}

    # Build the solution with new version
    - name: Build solution
      shell: bash
      # Umgebungsvariablen in Bash: $PROJECT_PATH (ohne env:)
      run: dotnet build $PROJECT_PATH --configuration Release /p:Version=${{ steps.version.outputs.version }} /p:EnableWindowsTargeting=true

    # Pack the NuGet package
    - name: Pack NuGet package
      id: pack
      shell: bash
      run: |
        PACKAGE_VERSION="${{ steps.version.outputs.version }}"
        # Der dotnet pack Befehl
        dotnet pack $PROJECT_PATH --configuration Release --no-build /p:PackageVersion=$PACKAGE_VERSION --output ./nupkg /p:EnableWindowsTargeting=true

        # Den exakten Paketnamen für den push-Schritt ermitteln und speichern (Fail-Safe)
        PACKAGE_NAME=$(basename $PROJECT_PATH .csproj | sed 's/\.csproj$//')
        NUPKG_PATH="./nupkg/${PACKAGE_NAME}.${PACKAGE_VERSION}.nupkg"

        # Setzt den exakten Pfad als Output
        echo "nupkg_path=$NUPKG_PATH" >> $GITHUB_OUTPUT

    # Publish to NuGet.org
    - name: Publish to NuGet (Fail-Safe)
      shell: bash
      # Jetzt den exakten Pfad verwenden (Lösung A/B kombiniert)
      run: dotnet nuget push ${{ steps.pack.outputs.nupkg_path }} --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate
